var BezierPath=function(t){"use strict";function s(t){const s=[];for(let e=0;e<t;e++)s.push(e);return s}class e{constructor(t,s,e,h){this._totalLength=void 0,this.A=t,this.B=s,this.C=e,this.D=h}static sampleSpacing(){return 2}tangentAtParameter(t){const s=Math.max(0,Math.min(1,t));if(0===s||1===s){let t,e;0===s?this.A.x===this.B.x&&this.A.y===this.B.y?(t=this.C.x-this.A.x,e=this.C.y-this.A.y):(t=this.B.x-this.A.x,e=this.B.y-this.A.y):this.D.x===this.C.x&&this.D.y===this.C.y?(t=this.D.x-this.B.x,e=this.D.y-this.B.y):(t=this.D.x-this.C.x,e=this.D.y-this.C.y);const h=Math.hypot(t,e);return Math.abs(h)>1e-4&&(t/=h,e/=h),{x:t,y:e}}const e=1-s;let h=3*this.D.x*Math.pow(s,2)-3*this.C.x*Math.pow(s,2)+6*this.C.x*e*s-6*this.B.x*e*s+3*this.B.x*Math.pow(e,2)-3*this.A.x*Math.pow(e,2),i=3*this.D.y*Math.pow(s,2)-3*this.C.y*Math.pow(s,2)+6*this.C.y*e*s-6*this.B.y*e*s+3*this.B.y*Math.pow(e,2)-3*this.A.y*Math.pow(e,2);const a=Math.hypot(h,i);return Math.abs(a)>1e-4&&(h/=a,i/=a),{x:h,y:i}}isLinear(){return this.A.x===this.B.x&&this.A.y===this.B.y&&this.C.x===this.D.x&&this.C.y===this.D.y}pointAtParameter(t){const s=Math.max(0,Math.min(1,t));return{x:Math.pow(1-s,3)*this.A.x+3*Math.pow(1-s,2)*s*this.B.x+3*(1-s)*Math.pow(s,2)*this.C.x+Math.pow(s,3)*this.D.x,y:Math.pow(1-s,3)*this.A.y+3*Math.pow(1-s,2)*s*this.B.y+3*(1-s)*Math.pow(s,2)*this.C.y+Math.pow(s,3)*this.D.y}}getTotalLength(){if(void 0===this._totalLength)if(this.isLinear())this._totalLength=Math.hypot(this.D.x-this.A.x,this.D.y-this.A.y);else{const t=Math.max(10,Math.ceil((Math.hypot(this.B.x-this.A.x,this.B.y-this.A.y)+Math.hypot(this.C.x-this.B.x,this.C.y-this.B.y)+Math.hypot(this.D.x-this.C.x,this.D.y-this.C.y))/e.sampleSpacing())),h=s(t).map(s=>this.pointAtParameter(s/(t-1)));let i=0;for(let t=1;t<h.length;t++)i+=Math.hypot(h[t].x-h[t-1].x,h[t].y-h[t-1].y);this._totalLength=i}return this._totalLength}}class h{constructor(t){this.samples=[],this.segments=t;const h=t.map(t=>t.getTotalLength()),i=[0];for(let t=1;t<h.length;t++)i.push(i[t-1]+h[t-1]);this._totalLength=i[i.length-1]+h[h.length-1];const a=t.map(t=>Math.max(4,Math.ceil(t.getTotalLength()/e.sampleSpacing()))),n=a.reduce((t,s)=>t+s),x=1/n/10,r=this._totalLength/n;this.samples.push({dist:0,pt:this.segments[0].A,tan:this.segments[0].tangentAtParameter(0),segIdx:0,t:0}),t.forEach((t,e)=>{const h=a[e],n=s(h+1).map(t=>t/h),y=n.map(s=>t.pointAtParameter(s));let p;for(let e=0;e<4;e++){p=s(h).map(t=>Math.hypot(y[t+1].x-y[t].x,y[t+1].y-y[t].y));const e=p.map(t=>t-r);let i=0;for(let s=1;s<n.length-1;s++)i+=e[s-1],n[s]-=x*i,y[s]=t.pointAtParameter(n[s])}let l=0;y.slice(1).forEach((t,s)=>{l+=p[s],this.samples.push({dist:i[e]+l,pt:t,tan:this.segments[e].tangentAtParameter(n[s+1]),segIdx:e,t:n[s+1]})})}),this._jumps=[],this.segmentStartEnds=[{start:0,end:0}];for(let t=1;t<this.samples.length;t++){let s=this.samples[t-1],e=this.samples[t];if(e.segIdx===s.segIdx)this.segmentStartEnds[this.segmentStartEnds.length-1].end=e.dist;else{const h=e.dist-Math.hypot(this.segments[e.segIdx].A.x-e.pt.x,this.segments[e.segIdx].A.y-e.pt.y);if(this.segments[s.segIdx].D.x!==this.segments[e.segIdx].A.x||this.segments[s.segIdx].D.y!==this.segments[e.segIdx].A.y){const i={dist:h-1e-8,pt:this.segments[s.segIdx].D,tan:this.segments[s.segIdx].tangentAtParameter(1),segIdx:s.segIdx,t:1},a={dist:h+1e-8,pt:this.segments[e.segIdx].A,tan:this.segments[e.segIdx].tangentAtParameter(0),segIdx:e.segIdx,t:0};this._jumps.push(h),this.samples.splice(t,0,i,a),this.segmentStartEnds[i.segIdx].end=i.dist,this.segmentStartEnds[a.segIdx]={start:a.dist,end:e.dist},t+=2}else if(0!==e.t){const s=Object.assign(Object.assign({},e),{t:0,pt:this.segments[e.segIdx].A,tan:this.segments[e.segIdx].tangentAtParameter(0),dist:h});this.samples.splice(t,0,s),this.segmentStartEnds[e.segIdx]={start:s.dist,end:e.dist},t++}else this.segmentStartEnds[e.segIdx]={start:e.dist,end:e.dist}}}}jumps(){return[...this._jumps]}getTotalLength(){return this._totalLength}findClosestSampleIdx(t){let s=0,e=this.samples.length-1;for(;s<e;){const h=Math.floor((s+e)/2);if(this.samples[h].dist>t)e=h-1;else{if(!(this.samples[h].dist<t))return h;s=h+1}}return Math.max(0,Math.min(this.samples.length-1,Math.floor((s+e)/2)))}getPointAtLength(t,s=!1){if(t<=0)return this.samples[0].pt;if(t>=this._totalLength)return this.samples[this.samples.length-1].pt;const e=this.findClosestSampleIdx(t),h=this.samples[e].dist<t?Math.min(e+1,this.samples.length-1):Math.max(0,e-1),i=Math.abs(this.samples[h].dist-this.samples[e].dist)<1e-6?0:(t-this.samples[e].dist)/(this.samples[h].dist-this.samples[e].dist);if(s||this.samples[e].segIdx>this.samples[h].segIdx){return{x:(1-i)*this.samples[e].pt.x+i*this.samples[h].pt.x,y:(1-i)*this.samples[e].pt.y+i*this.samples[h].pt.y}}if(this.samples[e].segIdx!==this.samples[h].segIdx){const t=1-this.samples[e].t+this.samples[h].t,s=t>0?(1-this.samples[e].t)/t:.5;if(i<s){const t=this.segments[this.samples[e].segIdx],h=i/s,a=(1-h)*this.samples[e].t+h;return t.pointAtParameter(a)}{const t=this.segments[this.samples[h].segIdx],e=(i-s)/(1-s)*this.samples[h].t;return t.pointAtParameter(e)}}{const t=this.segments[this.samples[e].segIdx],s=(1-i)*this.samples[e].t+i*this.samples[h].t;return t.pointAtParameter(s)}}getAngleAtLength(t,s=!1){const e=this.getTangentAtLength(t,s);return Math.atan2(e.y,e.x)}getTangentAtLength(t,s=!1){if(t<=0)return this.samples[0].tan;if(t>=this._totalLength)return this.samples[this.samples.length-1].tan;const e=this.findClosestSampleIdx(t),h=this.samples[e].dist<t?Math.min(e+1,this.samples.length-1):Math.max(0,e-1),i=(t-this.samples[e].dist)/(this.samples[h].dist-this.samples[e].dist);if(s||this.samples[e].segIdx>this.samples[h].segIdx){let t=(1-i)*this.samples[e].tan.x+i*this.samples[h].tan.x,s=(1-i)*this.samples[e].tan.y+i*this.samples[h].tan.y;const a=Math.max(Math.hypot(t,s),1e-4);return t/=a,s/=a,{x:t,y:s}}if(this.samples[e].segIdx!==this.samples[h].segIdx){if(i<.5){const t=this.segments[this.samples[e].segIdx],s=2*i,h=(1-s)*this.samples[e].t+s;return t.tangentAtParameter(h)}{const t=this.segments[this.samples[h].segIdx],s=2*(i-.5)*this.samples[h].t;return t.tangentAtParameter(s)}}{const t=this.segments[this.samples[e].segIdx],s=(1-i)*this.samples[e].t+i*this.samples[h].t;return t.tangentAtParameter(s)}}}const i={M:["x","y"],m:["dx","dy"],H:["x"],h:["dx"],V:["y"],v:["dy"],L:["x","y"],l:["dx","dy"],Z:[],C:["x1","y1","x2","y2","x","y"],c:["dx1","dy1","dx2","dy2","dx","dy"],S:["x2","y2","x","y"],s:["dx2","dy2","dx","dy"],Q:["x1","y1","x","y"],q:["dx1","dy1","dx","dy"],T:["x","y"],t:["dx","dy"],A:["rx","ry","rotation","large-arc","sweep","x","y"],a:["rx","ry","rotation","large-arc","sweep","dx","dy"]};const a=t=>{const s=function(t){const s=t.replace(/[\n\r]/g,"").replace(/-/g," -").replace(/(\d*\.)(\d+)(?=\.)/g,"$1$2 ").replace(/(\d)([A-Za-z])/g,"$1 $2").replace(/([A-Za-z])(\d)/g,"$1 $2").trim().split(/\s*,|\s+/),e=[];let h="",a={};for(;s.length>0;){let t=s.shift();i.hasOwnProperty(t)?h=t:s.unshift(t),a={type:h},i[h].forEach(e=>{t=s.shift(),a[e]=parseFloat(t)}),"M"===h?h="L":"m"===h&&(h="l"),e.push(a)}return e}(t.getAttribute("d"));if(s.length<2)throw new Error(`Path doesn't have enough commands: ${JSON.stringify(s)}`);if("M"!==s[0].type)throw new Error(`Path starts with ${s[0].type} instead of M!`);let a={x:s[0].x,y:s[0].y};s.shift();const n=[];for(;s.length>0;){const t=s.shift();if("C"===t.type)n.push(new e(a,{x:t.x1,y:t.y1},{x:t.x2,y:t.y2},{x:t.x,y:t.y})),a={x:t.x,y:t.y};else if("L"===t.type)n.push(new e(a,a,{x:t.x,y:t.y},{x:t.x,y:t.y})),a={x:t.x,y:t.y};else if("H"===t.type)n.push(new e(a,a,{x:t.x,y:a.y},{x:t.x,y:a.y})),a={x:t.x,y:a.y};else if("V"===t.type)n.push(new e(a,a,{x:a.x,y:t.y},{x:a.x,y:t.y})),a={x:a.x,y:t.y};else if("Z"!==t.type)throw new Error(`Unsupported path command ${t.type}; use only H, V, M, L, C, Z!`)}return new h(n)},n=t=>{const[s,i,a,n]=["x1","x2","y1","y2"].map(s=>parseFloat(t.getAttribute(s)||"0"));return new h([new e({x:s,y:a},{x:s,y:a},{x:i,y:n},{x:i,y:n})])},x=t=>{const[s,i,a]=["cx","cy","r"].map(s=>parseFloat(t.getAttribute(s)||"0")),n=1.3;return new h([new e({x:s-a,y:i},{x:s-a,y:i-n*a},{x:s+a,y:i-n*a},{x:s+a,y:i}),new e({x:s+a,y:i},{x:s+a,y:i+n*a},{x:s-a,y:i+n*a},{x:s-a,y:i})])};return t.BezierPath=h,t.BezierSegment=e,t.create=t=>{const s=[];for(let h=1;h<t.length;h++){const i=t[h-1],a=t[h];s.push(new e(i.pt,i.right||i.pt,a.left||a.pt,a.pt))}return new h(s)},t.createFromCircle=x,t.createFromCommands=t=>{const s=t.slice();if(s.length<2)throw new Error(`Path doesn't have enough commands: ${JSON.stringify(s)}`);if("M"!==s[0].type)throw new Error(`Path starts with ${s[0].type} instead of M!`);let i={x:s[0].x,y:s[0].y},a=Object.assign({},i);const n=[];for(;s.length>0;){const t=s.shift();if("M"===t.type)a={x:t.x,y:t.y},i=a;else if("C"===t.type)n.push(new e(i,{x:t.x1,y:t.y1},{x:t.x2,y:t.y2},{x:t.x,y:t.y})),i={x:t.x,y:t.y};else if("L"===t.type)t.x===i.x&&t.y===i.y||n.push(new e(i,i,{x:t.x,y:t.y},{x:t.x,y:t.y})),i={x:t.x,y:t.y};else if("H"===t.type)t.x!==i.x&&n.push(new e(i,i,{x:t.x,y:i.y},{x:t.x,y:i.y})),i={x:t.x,y:i.y};else if("V"===t.type)t.y!==i.y&&n.push(new e(i,i,{x:i.x,y:t.y},{x:i.x,y:t.y})),i={x:i.x,y:t.y};else if("Q"===t.type)n.push(new e(i,{x:i.x+2/3*(t.x1-i.x),y:i.y+2/3*(t.y1-i.y)},{x:t.x+2/3*(t.x1-t.x),y:t.y+2/3*(t.y1-t.y)},{x:t.x,y:t.y})),i={x:t.x,y:t.y};else{if("Z"!==t.type)throw new Error(`Unsupported path command ${t.type}; use only H, V, M, L, C, Z!`);Math.hypot(i.x-a.x,i.y-a.y)>0&&n.push(new e(i,i,a,a))}}return new h(n)},t.createFromElement=t=>{const s=t.tagName.toLowerCase();if("path"===s)return a(t);if("line"===s)return n(t);if("circle"===s)return x(t);throw new Error(`Unsupported SVG tag: ${s}`)},t.createFromLine=n,t.createFromPath=a,t}({});
